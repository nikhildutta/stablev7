/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import * as nestAccessControl from "nest-access-control";
import * as defaultAuthGuard from "../../auth/defaultAuth.guard";
import { AppUserService } from "../appUser.service";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { AppUserCreateInput } from "./AppUserCreateInput";
import { AppUser } from "./AppUser";
import { AppUserFindManyArgs } from "./AppUserFindManyArgs";
import { AppUserWhereUniqueInput } from "./AppUserWhereUniqueInput";
import { AppUserUpdateInput } from "./AppUserUpdateInput";
import { AccessLogFindManyArgs } from "../../accessLog/base/AccessLogFindManyArgs";
import { AccessLog } from "../../accessLog/base/AccessLog";
import { AccessLogWhereUniqueInput } from "../../accessLog/base/AccessLogWhereUniqueInput";
import { CouponRedemptionFindManyArgs } from "../../couponRedemption/base/CouponRedemptionFindManyArgs";
import { CouponRedemption } from "../../couponRedemption/base/CouponRedemption";
import { CouponRedemptionWhereUniqueInput } from "../../couponRedemption/base/CouponRedemptionWhereUniqueInput";
import { CustomerPreferenceFindManyArgs } from "../../customerPreference/base/CustomerPreferenceFindManyArgs";
import { CustomerPreference } from "../../customerPreference/base/CustomerPreference";
import { CustomerPreferenceWhereUniqueInput } from "../../customerPreference/base/CustomerPreferenceWhereUniqueInput";
import { CustomerSubscriptionFindManyArgs } from "../../customerSubscription/base/CustomerSubscriptionFindManyArgs";
import { CustomerSubscription } from "../../customerSubscription/base/CustomerSubscription";
import { CustomerSubscriptionWhereUniqueInput } from "../../customerSubscription/base/CustomerSubscriptionWhereUniqueInput";
import { ErrorLogFindManyArgs } from "../../errorLog/base/ErrorLogFindManyArgs";
import { ErrorLog } from "../../errorLog/base/ErrorLog";
import { ErrorLogWhereUniqueInput } from "../../errorLog/base/ErrorLogWhereUniqueInput";
import { FavouriteFindManyArgs } from "../../favourite/base/FavouriteFindManyArgs";
import { Favourite } from "../../favourite/base/Favourite";
import { FavouriteWhereUniqueInput } from "../../favourite/base/FavouriteWhereUniqueInput";
import { NotificationFindManyArgs } from "../../notification/base/NotificationFindManyArgs";
import { Notification } from "../../notification/base/Notification";
import { NotificationWhereUniqueInput } from "../../notification/base/NotificationWhereUniqueInput";
import { NotificationSettingFindManyArgs } from "../../notificationSetting/base/NotificationSettingFindManyArgs";
import { NotificationSetting } from "../../notificationSetting/base/NotificationSetting";
import { NotificationSettingWhereUniqueInput } from "../../notificationSetting/base/NotificationSettingWhereUniqueInput";
import { OrderHistoryFindManyArgs } from "../../orderHistory/base/OrderHistoryFindManyArgs";
import { OrderHistory } from "../../orderHistory/base/OrderHistory";
import { OrderHistoryWhereUniqueInput } from "../../orderHistory/base/OrderHistoryWhereUniqueInput";
import { ReportFindManyArgs } from "../../report/base/ReportFindManyArgs";
import { Report } from "../../report/base/Report";
import { ReportWhereUniqueInput } from "../../report/base/ReportWhereUniqueInput";
import { ReservationFindManyArgs } from "../../reservation/base/ReservationFindManyArgs";
import { Reservation } from "../../reservation/base/Reservation";
import { ReservationWhereUniqueInput } from "../../reservation/base/ReservationWhereUniqueInput";
import { RewardFindManyArgs } from "../../reward/base/RewardFindManyArgs";
import { Reward } from "../../reward/base/Reward";
import { RewardWhereUniqueInput } from "../../reward/base/RewardWhereUniqueInput";
import { SettlementsBreakupFindManyArgs } from "../../settlementsBreakup/base/SettlementsBreakupFindManyArgs";
import { SettlementsBreakup } from "../../settlementsBreakup/base/SettlementsBreakup";
import { SettlementsBreakupWhereUniqueInput } from "../../settlementsBreakup/base/SettlementsBreakupWhereUniqueInput";
import { SsoLookupFindManyArgs } from "../../ssoLookup/base/SsoLookupFindManyArgs";
import { SsoLookup } from "../../ssoLookup/base/SsoLookup";
import { SsoLookupWhereUniqueInput } from "../../ssoLookup/base/SsoLookupWhereUniqueInput";
import { SubscriptionFindManyArgs } from "../../subscription/base/SubscriptionFindManyArgs";
import { Subscription } from "../../subscription/base/Subscription";
import { SubscriptionWhereUniqueInput } from "../../subscription/base/SubscriptionWhereUniqueInput";
import { UserCustomerLookupFindManyArgs } from "../../userCustomerLookup/base/UserCustomerLookupFindManyArgs";
import { UserCustomerLookup } from "../../userCustomerLookup/base/UserCustomerLookup";
import { UserCustomerLookupWhereUniqueInput } from "../../userCustomerLookup/base/UserCustomerLookupWhereUniqueInput";
import { UserFeedbackFindManyArgs } from "../../userFeedback/base/UserFeedbackFindManyArgs";
import { UserFeedback } from "../../userFeedback/base/UserFeedback";
import { UserFeedbackWhereUniqueInput } from "../../userFeedback/base/UserFeedbackWhereUniqueInput";
import { UsersHashtagsMapFindManyArgs } from "../../usersHashtagsMap/base/UsersHashtagsMapFindManyArgs";
import { UsersHashtagsMap } from "../../usersHashtagsMap/base/UsersHashtagsMap";
import { UsersHashtagsMapWhereUniqueInput } from "../../usersHashtagsMap/base/UsersHashtagsMapWhereUniqueInput";

@swagger.ApiBearerAuth()
@common.UseGuards(defaultAuthGuard.DefaultAuthGuard, nestAccessControl.ACGuard)
export class AppUserControllerBase {
  constructor(
    protected readonly service: AppUserService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}
  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Post()
  @swagger.ApiCreatedResponse({ type: AppUser })
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "create",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async createAppUser(
    @common.Body() data: AppUserCreateInput
  ): Promise<AppUser> {
    return await this.service.createAppUser({
      data: data,
      select: {
        account_status: true,
        createdAt: true,
        id: true,
        profilePicUrl: true,
        updatedAt: true,
      },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get()
  @swagger.ApiOkResponse({ type: [AppUser] })
  @ApiNestedQuery(AppUserFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "read",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async appUsers(@common.Req() request: Request): Promise<AppUser[]> {
    const args = plainToClass(AppUserFindManyArgs, request.query);
    return this.service.appUsers({
      ...args,
      select: {
        account_status: true,
        createdAt: true,
        id: true,
        profilePicUrl: true,
        updatedAt: true,
      },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: AppUser })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "read",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async appUser(
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<AppUser | null> {
    const result = await this.service.appUser({
      where: params,
      select: {
        account_status: true,
        createdAt: true,
        id: true,
        profilePicUrl: true,
        updatedAt: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return result;
  }

  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: AppUser })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async updateAppUser(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() data: AppUserUpdateInput
  ): Promise<AppUser | null> {
    try {
      return await this.service.updateAppUser({
        where: params,
        data: data,
        select: {
          account_status: true,
          createdAt: true,
          id: true,
          profilePicUrl: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: AppUser })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "delete",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async deleteAppUser(
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<AppUser | null> {
    try {
      return await this.service.deleteAppUser({
        where: params,
        select: {
          account_status: true,
          createdAt: true,
          id: true,
          profilePicUrl: true,
          updatedAt: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/accessLogs")
  @ApiNestedQuery(AccessLogFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "AccessLog",
    action: "read",
    possession: "any",
  })
  async findAccessLogs(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<AccessLog[]> {
    const query = plainToClass(AccessLogFindManyArgs, request.query);
    const results = await this.service.findAccessLogs(params.id, {
      ...query,
      select: {
        action: true,

        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        deviceInfo: true,
        errorMessage: true,
        id: true,
        ipAddress: true,
        responseStatus: true,
        timestamp: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/accessLogs")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectAccessLogs(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: AccessLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accessLogs: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/accessLogs")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateAccessLogs(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: AccessLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accessLogs: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/accessLogs")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectAccessLogs(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: AccessLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accessLogs: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/couponRedemptions")
  @ApiNestedQuery(CouponRedemptionFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "CouponRedemption",
    action: "read",
    possession: "any",
  })
  async findCouponRedemptions(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<CouponRedemption[]> {
    const query = plainToClass(CouponRedemptionFindManyArgs, request.query);
    const results = await this.service.findCouponRedemptions(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        coupons: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        id: true,
        isRedeemed: true,
        redemptionDate: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/couponRedemptions")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectCouponRedemptions(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: CouponRedemptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      couponRedemptions: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/couponRedemptions")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateCouponRedemptions(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: CouponRedemptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      couponRedemptions: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/couponRedemptions")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectCouponRedemptions(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: CouponRedemptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      couponRedemptions: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/customerPreferences")
  @ApiNestedQuery(CustomerPreferenceFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "CustomerPreference",
    action: "read",
    possession: "any",
  })
  async findCustomerPreferences(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<CustomerPreference[]> {
    const query = plainToClass(CustomerPreferenceFindManyArgs, request.query);
    const results = await this.service.findCustomerPreferences(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        id: true,
        preferenceType: true,
        preferenceValue: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/customerPreferences")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectCustomerPreferences(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: CustomerPreferenceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerPreferences: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/customerPreferences")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateCustomerPreferences(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: CustomerPreferenceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerPreferences: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/customerPreferences")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectCustomerPreferences(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: CustomerPreferenceWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerPreferences: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/customerSubscriptions")
  @ApiNestedQuery(CustomerSubscriptionFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "CustomerSubscription",
    action: "read",
    possession: "any",
  })
  async findCustomerSubscriptions(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<CustomerSubscription[]> {
    const query = plainToClass(CustomerSubscriptionFindManyArgs, request.query);
    const results = await this.service.findCustomerSubscriptions(params.id, {
      ...query,
      select: {
        activationDate: true,

        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        expirationDate: true,
        id: true,
        renewalCount: true,

        subscriptionPlans: {
          select: {
            id: true,
          },
        },

        subscriptions: {
          select: {
            id: true,
          },
        },

        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/customerSubscriptions")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectCustomerSubscriptions(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: CustomerSubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerSubscriptions: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/customerSubscriptions")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateCustomerSubscriptions(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: CustomerSubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerSubscriptions: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/customerSubscriptions")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectCustomerSubscriptions(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: CustomerSubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      customerSubscriptions: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/errorLogs")
  @ApiNestedQuery(ErrorLogFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "ErrorLog",
    action: "read",
    possession: "any",
  })
  async findErrorLogs(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<ErrorLog[]> {
    const query = plainToClass(ErrorLogFindManyArgs, request.query);
    const results = await this.service.findErrorLogs(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        errorCode: true,
        errorMessage: true,
        id: true,
        requestInfo: true,
        stackTrace: true,
        timestamp: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/errorLogs")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectErrorLogs(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: ErrorLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      errorLogs: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/errorLogs")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateErrorLogs(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: ErrorLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      errorLogs: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/errorLogs")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectErrorLogs(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: ErrorLogWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      errorLogs: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/favourites")
  @ApiNestedQuery(FavouriteFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Favourite",
    action: "read",
    possession: "any",
  })
  async findFavourites(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<Favourite[]> {
    const query = plainToClass(FavouriteFindManyArgs, request.query);
    const results = await this.service.findFavourites(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        id: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/favourites")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectFavourites(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: FavouriteWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      favourites: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/favourites")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateFavourites(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: FavouriteWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      favourites: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/favourites")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectFavourites(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: FavouriteWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      favourites: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/notifications")
  @ApiNestedQuery(NotificationFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Notification",
    action: "read",
    possession: "any",
  })
  async findNotifications(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<Notification[]> {
    const query = plainToClass(NotificationFindManyArgs, request.query);
    const results = await this.service.findNotifications(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        id: true,
        isRead: true,
        message: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/notifications")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectNotifications(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: NotificationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notifications: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/notifications")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateNotifications(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: NotificationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notifications: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/notifications")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectNotifications(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: NotificationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notifications: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/notificationSettings")
  @ApiNestedQuery(NotificationSettingFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "NotificationSetting",
    action: "read",
    possession: "any",
  })
  async findNotificationSettings(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<NotificationSetting[]> {
    const query = plainToClass(NotificationSettingFindManyArgs, request.query);
    const results = await this.service.findNotificationSettings(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        id: true,
        settingName: true,
        settingValue: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/notificationSettings")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectNotificationSettings(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: NotificationSettingWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notificationSettings: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/notificationSettings")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateNotificationSettings(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: NotificationSettingWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notificationSettings: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/notificationSettings")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectNotificationSettings(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: NotificationSettingWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      notificationSettings: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/orderHistory")
  @ApiNestedQuery(OrderHistoryFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "OrderHistory",
    action: "read",
    possession: "any",
  })
  async findOrderHistory(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<OrderHistory[]> {
    const query = plainToClass(OrderHistoryFindManyArgs, request.query);
    const results = await this.service.findOrderHistory(params.id, {
      ...query,
      select: {
        addresses: {
          select: {
            id: true,
          },
        },

        appUsers: {
          select: {
            id: true,
          },
        },

        coupons: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        deliveryTipsAmount: true,
        discountAmount: true,
        estimatedDeliveryTime: true,
        finalAmount: true,
        id: true,
        isCancelled: true,
        isFulfilled: true,
        isPaid: true,
        isRejected: true,
        orderDateTime: true,
        orderIdRef: true,
        order_type: true,
        packagingAmount: true,

        paymentMethods: {
          select: {
            id: true,
          },
        },

        preparationInstruction: true,
        preparationTime: true,
        rejectedBy: true,

        restaurants: {
          select: {
            id: true,
          },
        },

        totalAmount: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/orderHistory")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectOrderHistory(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: OrderHistoryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      orderHistory: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/orderHistory")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateOrderHistory(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: OrderHistoryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      orderHistory: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/orderHistory")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectOrderHistory(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: OrderHistoryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      orderHistory: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/reports")
  @ApiNestedQuery(ReportFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Report",
    action: "read",
    possession: "any",
  })
  async findReports(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<Report[]> {
    const query = plainToClass(ReportFindManyArgs, request.query);
    const results = await this.service.findReports(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        id: true,
        reportData: true,
        reportType: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/reports")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectReports(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: ReportWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reports: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/reports")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateReports(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: ReportWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reports: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/reports")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectReports(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: ReportWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reports: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/reservations")
  @ApiNestedQuery(ReservationFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Reservation",
    action: "read",
    possession: "any",
  })
  async findReservations(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<Reservation[]> {
    const query = plainToClass(ReservationFindManyArgs, request.query);
    const results = await this.service.findReservations(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        id: true,
        partySize: true,
        reservationDate: true,
        reservationTime: true,

        restaurants: {
          select: {
            id: true,
          },
        },

        status: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/reservations")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectReservations(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: ReservationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reservations: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/reservations")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateReservations(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: ReservationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reservations: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/reservations")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectReservations(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: ReservationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      reservations: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/rewards")
  @ApiNestedQuery(RewardFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Reward",
    action: "read",
    possession: "any",
  })
  async findRewards(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<Reward[]> {
    const query = plainToClass(RewardFindManyArgs, request.query);
    const results = await this.service.findRewards(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        expirationDate: true,
        id: true,
        points: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/rewards")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectRewards(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: RewardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      rewards: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/rewards")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateRewards(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: RewardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      rewards: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/rewards")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectRewards(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: RewardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      rewards: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/settlementsBreakup")
  @ApiNestedQuery(SettlementsBreakupFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "SettlementsBreakup",
    action: "read",
    possession: "any",
  })
  async findSettlementsBreakup(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<SettlementsBreakup[]> {
    const query = plainToClass(SettlementsBreakupFindManyArgs, request.query);
    const results = await this.service.findSettlementsBreakup(params.id, {
      ...query,
      select: {
        amountForGstUnder95: true,
        amountForTcs: true,

        appUsers: {
          select: {
            id: true,
          },
        },

        bankUtr: true,
        baseServiceFee: true,
        baseServiceFeePercentage: true,
        businessname: true,
        cancellationOrRejectionReason: true,
        cancellationOrRejectionState: true,
        cancellationPolicy: true,
        cashReceivedSelfDelivery: true,
        commissionableAmount: true,
        createdAt: true,
        creditDebitNoteAdjustment: true,
        customerCompensation: true,
        customerPayable: true,
        deliveryCharge: true,
        deliveryChargesRecovery: true,
        deliveryStateCode: true,
        discountConstruct: true,
        extraInventoryAds: true,
        fulfilmentFee: true,
        fulfilmentFeePerKm: true,
        gstPaidByPlatform: true,
        gstToBePaidByRestaurant: true,
        id: true,
        netAdditions: true,
        netDeductions: true,
        orderDateTime: true,
        orderDistanceKm: true,

        orderHistory: {
          select: {
            id: true,
          },
        },

        orderLevelPayout: true,
        orderStatus: true,
        orderType: true,
        packagingCharge: true,
        paymentMechanismFee: true,
        paymentMode: true,

        payoutCycles: {
          select: {
            id: true,
          },
        },

        promoRecoveryAdjustment: true,
        restaurantDiscountFromOthers: true,
        restaurantDiscountFromPromo: true,
        restaurantId: true,
        settlementDate: true,
        settlementStatus: true,
        subtotal: true,
        taxCollectedAtSource: true,
        taxesOnServicePaymentFees: true,
        tcsIgstAmount: true,
        tds194OAmount: true,
        totalGstFromCustomers: true,
        unsettledAmount: true,
        updatedAt: true,
        weekNo: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/settlementsBreakup")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectSettlementsBreakup(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: SettlementsBreakupWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      settlementsBreakup: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/settlementsBreakup")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateSettlementsBreakup(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: SettlementsBreakupWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      settlementsBreakup: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/settlementsBreakup")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectSettlementsBreakup(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: SettlementsBreakupWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      settlementsBreakup: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/ssoLookup")
  @ApiNestedQuery(SsoLookupFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "SsoLookup",
    action: "read",
    possession: "any",
  })
  async findSsoLookup(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<SsoLookup[]> {
    const query = plainToClass(SsoLookupFindManyArgs, request.query);
    const results = await this.service.findSsoLookup(params.id, {
      ...query,
      select: {
        appleEmail: true,
        appleFamilyName: true,
        appleGivenName: true,
        appleRefreshToken: true,
        appleTokenExpiresAt: true,
        appleUserId: true,

        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        facebookAccessToken: true,
        facebookEmail: true,
        facebookName: true,
        facebookTokenExpiresAt: true,
        facebookUserId: true,
        googleEmail: true,
        googleFamilyName: true,
        googleGivenName: true,
        googleRefreshToken: true,
        googleTokenExpiresAt: true,
        googleUserId: true,
        id: true,
        twitterAccessToken: true,
        twitterHandle: true,
        twitterTokenSecret: true,
        twitterUserId: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/ssoLookup")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectSsoLookup(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: SsoLookupWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      ssoLookup: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/ssoLookup")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateSsoLookup(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: SsoLookupWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      ssoLookup: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/ssoLookup")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectSsoLookup(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: SsoLookupWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      ssoLookup: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/subscriptions")
  @ApiNestedQuery(SubscriptionFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Subscription",
    action: "read",
    possession: "any",
  })
  async findSubscriptions(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<Subscription[]> {
    const query = plainToClass(SubscriptionFindManyArgs, request.query);
    const results = await this.service.findSubscriptions(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        autoRenew: true,
        createdAt: true,
        endDate: true,
        id: true,
        paymentStatus: true,
        startDate: true,
        status: true,

        subscriptionPlans: {
          select: {
            id: true,
          },
        },

        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/subscriptions")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectSubscriptions(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: SubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      subscriptions: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/subscriptions")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateSubscriptions(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: SubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      subscriptions: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/subscriptions")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectSubscriptions(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: SubscriptionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      subscriptions: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/userCustomerLookup")
  @ApiNestedQuery(UserCustomerLookupFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "UserCustomerLookup",
    action: "read",
    possession: "any",
  })
  async findUserCustomerLookup(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<UserCustomerLookup[]> {
    const query = plainToClass(UserCustomerLookupFindManyArgs, request.query);
    const results = await this.service.findUserCustomerLookup(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        customers: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/userCustomerLookup")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectUserCustomerLookup(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: UserCustomerLookupWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userCustomerLookup: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/userCustomerLookup")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateUserCustomerLookup(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: UserCustomerLookupWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userCustomerLookup: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/userCustomerLookup")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectUserCustomerLookup(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: UserCustomerLookupWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userCustomerLookup: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/userFeedbacks")
  @ApiNestedQuery(UserFeedbackFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "UserFeedback",
    action: "read",
    possession: "any",
  })
  async findUserFeedbacks(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<UserFeedback[]> {
    const query = plainToClass(UserFeedbackFindManyArgs, request.query);
    const results = await this.service.findUserFeedbacks(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        feedbackText: true,
        id: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/userFeedbacks")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectUserFeedbacks(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: UserFeedbackWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userFeedbacks: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/userFeedbacks")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateUserFeedbacks(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: UserFeedbackWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userFeedbacks: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/userFeedbacks")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectUserFeedbacks(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: UserFeedbackWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      userFeedbacks: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/usersHashtagsMap")
  @ApiNestedQuery(UsersHashtagsMapFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "UsersHashtagsMap",
    action: "read",
    possession: "any",
  })
  async findUsersHashtagsMap(
    @common.Req() request: Request,
    @common.Param() params: AppUserWhereUniqueInput
  ): Promise<UsersHashtagsMap[]> {
    const query = plainToClass(UsersHashtagsMapFindManyArgs, request.query);
    const results = await this.service.findUsersHashtagsMap(params.id, {
      ...query,
      select: {
        appUsers: {
          select: {
            id: true,
          },
        },

        hashtags: {
          select: {
            id: true,
          },
        },

        id: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/usersHashtagsMap")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async connectUsersHashtagsMap(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: UsersHashtagsMapWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      usersHashtagsMap: {
        connect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/usersHashtagsMap")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async updateUsersHashtagsMap(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: UsersHashtagsMapWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      usersHashtagsMap: {
        set: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/usersHashtagsMap")
  @nestAccessControl.UseRoles({
    resource: "AppUser",
    action: "update",
    possession: "any",
  })
  async disconnectUsersHashtagsMap(
    @common.Param() params: AppUserWhereUniqueInput,
    @common.Body() body: UsersHashtagsMapWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      usersHashtagsMap: {
        disconnect: body,
      },
    };
    await this.service.updateAppUser({
      where: params,
      data,
      select: { id: true },
    });
  }
}
